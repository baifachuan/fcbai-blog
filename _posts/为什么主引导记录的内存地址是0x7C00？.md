---
title: 为什么主引导记录的内存地址是0x7C00？
tags: 编程基础
categories: 编程基础
abbrlink: c992b5b5
date: 2020-11-29 18:09:43
---

大学计算机的课程都会讲到mbr的引导地址是0x7c00，但是这个奇怪的地址，是怎么来的，课本就不解释了，那么为什么不存入内存的头部、尾部、或者其他位置，而偏偏存入这个比 32KB 小1024字节的地方？

首先我们看计算机启动的步骤：
* 通电
* 读取ROM里面的BIOS，用来检查硬件
* 硬件检查通过
* BIOS根据指定的顺序，检查引导设备的第一个扇区（即主引导记录），加载在内存地址 0x7C00
* 主引导记录把操作权交给操作系统


主引导记录就是引导"操作系统"进入内存的一段小程序，大小不超过1个扇区（512字节），0x7C00这个地址来自Intel的第一代个人电脑芯片8088，以后的CPU为了保持兼容，一直使用这个地址，1981年8月，IBM公司最早的个人电脑IBM PC 5150上市，就用了这个芯片，当时，搭配的操作系统是86-DOS。这个操作系统需要的内存最少是32KB。我们知道，内存地址从 ` 0x0000 ` 开始编号，32KB的内存就` 是0x0000～0x7FFF `。

8088芯片本身需要占用0x0000～0x03FF，用来保存各种中断处理程序的储存位置。（主引导记录本身就是中断信号INT 19h的处理程序。）所以，内存只剩下` 0x0400～0x7FFF `可以使用。

为了把尽量多的连续内存留给操作系统，主引导记录就被放到了内存地址的尾部。由于一个扇区是512字节，主引导记录本身也会产生数据，需要另外留出512字节保存。所以，它的预留位置就变成了：

```
  0x7FFF - 512 - 512 + 1 = 0x7C00 
```

0x7C00就是这样来的。

计算机启动后，32KB内存的使用情况如下：

```
+--------------------- 0x0
| Interrupts vectors
+--------------------- 0x400
| BIOS data area
+--------------------- 0x5??
| OS load area
+--------------------- 0x7C00
| Boot sector
+--------------------- 0x7E00
| Boot data/stack
+--------------------- 0x7FFF
| (not used)
+--------------------- (...)
```

算是，一个历史级别的概念吧。



